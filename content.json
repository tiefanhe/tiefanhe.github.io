{"meta":{"title":"AClocker","subtitle":null,"description":"A tech blog","author":"Tiefanhe","url":"http://aclocker.com"},"pages":[],"posts":[{"title":"[790] Domino and Tromino Tiling","slug":"790-Domino-and-Tromino-Tiling","date":"2018-09-13T15:01:39.000Z","updated":"2018-09-14T06:31:13.433Z","comments":true,"path":"2018/09/13/790-Domino-and-Tromino-Tiling/","link":"","permalink":"http://aclocker.com/2018/09/13/790-Domino-and-Tromino-Tiling/","excerpt":"","text":"S and T a","categories":[{"name":"programing","slug":"programing","permalink":"http://aclocker.com/categories/programing/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://aclocker.com/tags/leetcode/"},{"name":"Medium","slug":"Medium","permalink":"http://aclocker.com/tags/Medium/"}]},{"title":"[leetcode 791] Custom Sort String","slug":"leetcode-791-Custom-Sort-String","date":"2018-09-13T15:01:39.000Z","updated":"2018-09-14T06:19:08.809Z","comments":true,"path":"2018/09/13/leetcode-791-Custom-Sort-String/","link":"","permalink":"http://aclocker.com/2018/09/13/leetcode-791-Custom-Sort-String/","excerpt":"","text":"S and T are strings composed of lowercase letters. In S, no letter occurs more than once.S was sorted in some custom order previously. We want to permute the characters of T so that they match the order that S was sorted. More specifically, if x occurs before y in S, then x should occur before y in the returned string.Return any permutation of T (as a string) that satisfies this property.Example :Input:S = “cba”T = “abcd”Output: “cbad”Explanation:“a”, “b”, “c” appear in S, so the order of “a”, “b”, “c” should be “c”, “b”, and “a”.Since “d” does not appear in S, it can be at any position in T. “dcba”, “cdba”, “cbda” are also valid outputs. Note:S has length at most 26, and no character is repeated in S.T has length at most 200.S and T consist of lowercase letters only. 题目大意给定字符串S和T，S中的字母互不重复。将T中的字母调整顺序，使其字母之间的先后关系与S中的字母保持一致。对于S中没有出现的字符，顺序任意。 解题思路：统计T中各字符出现的次数按照S的顺序将T中字符进行重排，将剩余字符排在末尾。解题思路：统计T中各字符出现的次数按照S的顺序将T中字符进行重排，将剩余字符排在末尾。 1234567891011121314class Solution &#123; public String customSortString(String S, String T) &#123; int[] count = new int[26]; for (char c : T.toCharArray()) &#123; ++count[c - 'a']; &#125; // count each char in T. StringBuilder sb = new StringBuilder(); for (char c : S.toCharArray()) &#123; while (count[c - 'a']-- &gt; 0) &#123; sb.append(c); &#125; // sort chars both in T and S by the order of S. &#125; for (char c = 'a'; c &lt;= 'z'; ++c) &#123; while (count[c - 'a']-- &gt; 0) &#123; sb.append(c); &#125; // group chars in T but not in S. &#125; return sb.toString(); &#125;&#125;","categories":[{"name":"programing","slug":"programing","permalink":"http://aclocker.com/categories/programing/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://aclocker.com/tags/leetcode/"},{"name":"Medium","slug":"Medium","permalink":"http://aclocker.com/tags/Medium/"}]},{"title":"Leetcode 解题报告","slug":"Leetcode-解题报告","date":"2018-09-13T13:25:24.000Z","updated":"2018-09-14T06:19:23.594Z","comments":true,"path":"2018/09/13/Leetcode-解题报告/","link":"","permalink":"http://aclocker.com/2018/09/13/Leetcode-解题报告/","excerpt":"","text":"状态 题号 解题报告 分类 难度 809 Expressive Words Algorithm medium 791 Custom Sort String Algorithm medium","categories":[{"name":"置顶","slug":"置顶","permalink":"http://aclocker.com/categories/置顶/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://aclocker.com/tags/leetcode/"}]},{"title":"[leetcode 809] Expressive Words","slug":"leetcode/809-Expressive-Words","date":"2018-09-11T13:01:50.000Z","updated":"2018-09-14T05:05:23.569Z","comments":true,"path":"2018/09/11/leetcode/809-Expressive-Words/","link":"","permalink":"http://aclocker.com/2018/09/11/leetcode/809-Expressive-Words/","excerpt":"","text":"Sometimes people repeat letters to represent extra feeling, such as “hello” -&gt; “heeellooo”, “hi” -&gt; “hiiii”. Here, we have groups, of adjacent letters that are all the same character, and adjacent characters to the group are different. A group is extended if that group is length 3 or more, so “e” and “o” would be extended in the first example, and “i” would be extended in the second example. As another example, the groups of “abbcccaaaa” would be “a”, “bb”, “ccc”, and “aaaa”; and “ccc” and “aaaa” are the extended groups of that string. For some given string S, a query word is stretchy if it can be made to be equal to S by extending some groups. Formally, we are allowed to repeatedly choose a group (as defined above) of characters c, and add some number of the same character c to it so that the length of the group is 3 or more. Note that we cannot extend a group of size one like “h” to a group of size two like “hh” - all extensions must leave the group extended - ie., at least 3 characters long. Given a list of query words, return the number of words that are stretchy. 12345678Example:Input: S = &quot;heeellooo&quot;words = [&quot;hello&quot;, &quot;hi&quot;, &quot;helo&quot;]Output: 1Explanation: We can extend &quot;e&quot; and &quot;o&quot; in the word &quot;hello&quot; to get &quot;heeellooo&quot;.We can&apos;t extend &quot;helo&quot; to get &quot;heeellooo&quot; because the group &quot;ll&quot; is not extended. 题目大意给出一个长字符串S， 以及一个words list。 Words 里面每个word，可以通过扩展当前的char，来尝试构造S。extend的规则是，S中的char，必须连续出现&gt;=3 才可以extend。问，words里面会有几个word 能够extend到S中. 123456789101112131415161718192021222324252627282930class Solution &#123; public int expressiveWords(String S, String[] words) &#123; int res = 0; for(int n = 0; n &lt; words.length; n++ )&#123; //遍历每个 单词， 只需要考虑word 长度小于S的，否则肯定不能作为result。 if(words[n].length() &lt;= S.length())&#123; //两个指针， 分别从头开始遍历word 和S int i, j; for (i = 0, j = 0; j &lt; S.length(); j++) &#123; //如果当前i没有到达word 末尾。且 当前word的char == S的char， 则将i指针向前移动。 if (i &lt; words[n].length() &amp;&amp; words[n].charAt(i) == S.charAt(j)) &#123; i++; &#125; //否则的话，当前word的char ！= S的当前word char， 需要判断，当前S的char 和前一个以及后一个 是否相等。如果相等，则跳过当前char， 在for里面回跳过下一个char，进而将S的指针向后移动。 else if (j &gt; 0 &amp;&amp; S.charAt(j) ==S.charAt(j-1) &amp;&amp; j + 1 &lt; S.length() &amp;&amp; S.charAt(j) == S.charAt(j+1))&#123; j++; &#125; //如果S的当前char 不等于 前一个或者前两个，则直接跳过该单词。 else if (!(j &gt; 1 &amp;&amp; S.charAt(j) ==S.charAt(j-1) &amp;&amp; S.charAt(j) ==S.charAt(j-2)))&#123; break; &#125; &#125; if (i == words[n].length() &amp;&amp; j == S.length()) // both pointers reach the end res++; &#125; &#125; return res; &#125;&#125;","categories":[{"name":"programing","slug":"programing","permalink":"http://aclocker.com/categories/programing/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://aclocker.com/tags/leetcode/"},{"name":"Medium","slug":"Medium","permalink":"http://aclocker.com/tags/Medium/"}]}]}